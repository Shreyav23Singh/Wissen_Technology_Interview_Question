Q1 . What is the output of these code?

class Newthread extends Thread{
    Thread t; 
    String name;
    Newthread(String threadname){
        name=threadname;
        t=new Thread(this,name);
        t.start();
    }
    public void run(){
        
    }
    
}
class multithreaded_programming{
    public static void main(String args[]){
        Newthread obj1 =new Newthread("one");
        Newthread obj2 =new Newthread("two");
        try
        {
            obj1.t.wait();
            System.out.print(obj1.t.isAlive());
        }
        catch(Exception e){
            System.out.print("Main thread interrupted");
        }
    }
}

Output :- catch will execute and print statement will give i.e, Main thread interupted

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q2. what will happen if two java threads of the same priority are called to be processed simultaneously . Assumption only one CPU are available. 
1. Anyone will be executed first lexographically 
2. Both of them will be executed simultaneously 
3. None of them will be executed 
4. Decision will be taken up by os 

Ans : 4 
When two Java threads of the same priority are competing for the same CPU and only one CPU is available, the Java Virtual Machine (JVM) or the underlying operating system 
will decide which thread to execute. This decision is typically made by the operating system's thread scheduler.

The correct option is:

4. Decision will be taken up by the OS

The operating system's thread scheduler uses different scheduling algorithms to determine which thread gets to execute. The specific algorithm used may vary depending on 
the operating system. Common scheduling algorithms include round-robin, priority scheduling, and others.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q3. what will be the output of this code?
public class San{
    public static void main(String[] args){
        try{
            System.out.println("Hello World");
        }finally{
            System.out.println("finally executing");
        }
    }
    
}

Ans : Hello World
finally executing
The output of the given code will be:

```
Hello World
finally executing
```

In Java, the `finally` block is used to ensure that a certain piece of code is always executed, whether an exception is thrown or not. In this case, the `try` block contains
the statement `System.out.println("Hello World")`, which will be executed. After that, the `finally` block is executed, printing "finally executing."

Even if there were an exception thrown inside the `try` block, the `finally` block would still be executed before the exception is propagated up the call stack. 
In this specific example, since there's no exception, both the `try` block and the `finally` block are executed in sequence.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q4. User

how much space will be required to store variable ? consider the each data sent place.

class HelloWorld {
    public static void main(String[] args) {
        String[] temp ={"Hi" , "participants"};
        int length=temp.length;
        for(int i=0;i<temp.length;i++){
            System.out.println(temp[i]);
        }
    }
}
1.  7
2.  3
3. 5
4. 4
Ans : 4
--------------------------------------------------------------------------------------------------------------------------------------------------
Q5. which java collection provides constant time on an average for basic operation like add , remove and contains . (Assuming there is a no hash collision ) 
1. TreeSet 
2. LinkedList 
3. HashSet(Ans)
4. TreeMap
Ans :
The Java collection that provides constant time on average for basic operations like add, remove, and contains (assuming no hash collision) is HashSet. HashSet is implemented using a hash table,
and if there are no hash collisions, the average time complexity for these operations is O(1).

In Java collections, the time complexity of basic operations like add, remove, and contains can vary based on the specific collection implementation.
Let's discuss the mentioned options:

TreeSet: This is typically implemented as a Red-Black Tree. The add, remove, and contains operations have a time complexity of O(log n) on average,
where n is the number of elements. It is not constant time but logarithmic.

LinkedList: The time complexity for add and remove operations in a LinkedList is O(1) when adding or removing elements at the beginning or end of the list.
However, for contains (searching), the time complexity is O(n) in the worst case, where n is the number of elements.

HashSet: Implemented using a hash table, the average time complexity for add, remove, and contains operations is O(1) under the assumption of a good hash 
function and minimal collisions. However, in rare cases with hash collisions, the time complexity can degrade to O(n), where n is the number of elements.

TreeMap: Similar to TreeSet, TreeMap is implemented as a Red-Black Tree. The average time complexity for add, remove, and contains operations is O(log n),
where n is the number of elements.


--------------------------------------------------------------------------------------------------------------------------------------------------
